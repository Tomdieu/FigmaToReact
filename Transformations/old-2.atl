-- @path React=/Figma2React/Metamodel/react_meta_model.ecore
-- @path Figma=/Figma2React/Metamodel/figma_meta_model.ecore

module transformer;
create OUT : React from IN : Figma;

-- Helper functions to check node types
helper context Figma!Children def : isCanvas() : Boolean = 
    if self.type.toString() = 'CANVAS' then
        true
    else
        false
    endif;

helper context Figma!FRAME def : isScreen() : Boolean =
    not self.name.oclIsUndefined() and 
    (self.name.toLowerCase().indexOf('screen') <> -1 or 
     self.name.toLowerCase().indexOf('page') <> -1);

helper context Figma!FRAME def : isCheckbox() : Boolean =
    not self.name.oclIsUndefined() and 
    self.name.toLowerCase().indexOf('checkbox') <> -1;

helper context Figma!Children def : isFrame() : Boolean = 
    if self.type.toString() = 'FRAME' then
        true
    else
        false
    endif;

helper context Figma!Children def : isRectangle() : Boolean = 
	if self.type.toString() = 'RECTANGLE' then
		true
	else
		false
	
	endif;

helper context Figma!Children def : isText() : Boolean = 
	if self.type.toString() = 'TEXT' then
		true
	else
		false
	endif;

helper context Figma!Children def : isLine() : Boolean = 
	if self.type.toString() = 'LINE' then
		true
	else
		false
	endif;

helper context Figma!Children def : isComponent() : Boolean = 
	if self.type.toString() = 'COMPONENT' then
		true
	else
		false
	endif;

helper context Figma!Children def : isComponentSet() : Boolean = 
    if self.type.toString() = 'COMPONENT_SET' then
        true
    else
        false
    endif;
    
helper context Figma!Children def : isDocument() : Boolean = 
	if self.type.toString() = 'DOCUMENT' then
		true
	else
		false
	endif;

helper context Figma!Children def : isInstance() : Boolean = 
    if self.type.toString() = 'INSTANCE' then 
        true 
    else 
        false 
endif;

helper context Figma!Children def : isVector() : Boolean = 
	if self.type.toString() = 'VECTOR' then
		true
	else
		false
endif;

helper context Figma!Children def : isEllipse(): Boolean = 
	if self.type.toString() = 'ELLIPSE' then
		true
	else
		false
endif;

helper context Figma!Children def : isGroup() : Boolean = 
	if self.type.toString() = 'GROUP' then
		true
	else
		false
endif;

helper context Figma!Children def : isRegularPolygon() : Boolean =
	if self.type.toString() = 'REGULAR_POLYGON' then
		true
	else
		false
endif;

helper def : sanitizeName(name : String) : String =
    name.replaceAll(' ', '-').toLower();


rule FigmaApp2ReactApp {
	from
		F : Figma!FigmaApp
	to 
		R : React!ReactApplication (
			name <- F.name,
			router <- F.document
		)
}


--rule FigmaDocument2ReactRouter {
--	from
--		F : Figma!Document
--	to 
--		R : React!Router (
--			basname <- F.name,
--            route <- F.children->select(c | c.isCanvas())->collect(canvas | 
--                thisModule.CreateRoute(canvas)
--            )
--		)
--}

rule FigmaDocument2ReactRouter {
    from
        F : Figma!Document
    to 
        R : React!Router (
            basname <- F.name,
            route <- 
                -- Get routes from canvases
                F.children->select(c | c.isCanvas())->collect(canvas | 
                    thisModule.CreateRoute(canvas)
                )->union(
                -- Get routes from screen frames (with better type checking)
                F.children->iterate(c; acc : Sequence(React!Route) = Sequence{} |
                    acc->union(
                        if c.isFrame() then
                            -- Check if it's a screen frame
                            if c.name.oclIsUndefined() = false and c.name.toLowerCase().indexOf('screen') <> -1 then
                                Sequence{thisModule.CreateRouteFromScreen(c)}
                            else if not c.children.oclIsUndefined() then
                                -- Look for screens in children that are frames
                                c.children->select(child | 
                                    child.isFrame() and 
                                    child.name.oclIsUndefined() = false and 
                                    child.name.toLowerCase().indexOf('screen') <> -1
                                )->collect(screen | 
                                    thisModule.CreateRouteFromScreen(screen)
                                )
                            else
                                Sequence{}
                            endif endif
                        else
                            Sequence{}
                        endif
                    )
                ))
        )
}

-- Helper rule to create a route from a screen frame
lazy rule CreateRouteFromScreen {
    from
        F : Figma!FRAME
    to
        R : React!Route (
            path <- '/' + thisModule.sanitizeName(F.name.toLowerCase()),
            exact <- true,
            element <- thisModule.resolveTemp(F, 'R')
        )
}

-- Helper rule to create a route for a canvas

lazy rule CreateRoute {
    from
        F : Figma!CANVAS
    to
        R : React!Route (
            path <- '/' + thisModule.sanitizeName(F.name.toLowerCase()),
            exact <- true,
            element <- thisModule.resolveTemp(F, 'R')  -- This will resolve to the Page component created by FigmaCanvas2ReactComponent
        )
}

helper def : toComponentName(name:String) : String =
   let words : Sequence(String) = 
       name.split(' ')->reject(w | w = '')
   in
   words->iterate(w; acc : String = '' | 
       acc + w.substring(1, 1).toUpper() + 
       if w.size() > 1 then
           w.substring(2, w.size())
       else
           ''
       endif
   );

--rule FigmaCanvas2ReactComponent {
--	from
--		F : Figma!CANVAS(F.isCanvas())
--	to 
--		R : React!Page (
--			name <- thisModule.toComponentName(F.name),
--			key <- F.id,
--            children <- if not F.children.oclIsUndefined() then
--                F.children->collect(e | thisModule.resolveTemp(e, 'R'))
--            else
--                Sequence {}
--            endif
--		)
--}

rule FigmaCanvas2ReactComponent {
    from
        F : Figma!CANVAS(F.isCanvas())
    to 
        R : React!Page (
            name <- thisModule.toPascalCase(F.name),
            key <- F.id,
            children <- if not F.children.oclIsUndefined() then
                -- Filter out screen frames using direct checks instead of isScreen()
                F.children->reject(c | 
                    c.isFrame() and 
                    not c.name.oclIsUndefined() and 
                    c.name.toLowerCase().indexOf('screen') <> -1
                )->collect(e | 
                    thisModule.resolveTemp(e, 'R')
                )
            else
                Sequence {}
            endif
        )
}

rule FigmaScreen2ReactPage {
    from
        F : Figma!FRAME(F.isFrame() and F.isScreen())
    to 
        R : React!Page (
            name <- thisModule.toPascalCase(F.name),
            key <- F.id,
            children <- if not F.children.oclIsUndefined() then
                F.children->collect(e | thisModule.resolveTemp(e, 'R'))
            else
                Sequence {}
            endif
        )
}

rule VectorToSvg {
    from
        F: Figma!Children(F.isVector())
    to
        R: React!HTMLElement(
            name <- 'svg',
            isSelfClosing <- false,
            key <- F.id,
            attributes <- Sequence {
                thisModule.CreateAttribute('viewBox', 
                    if not F.absoluteBoundingBox.oclIsUndefined() then
                        '0 0 ' + F.absoluteBoundingBox.width.toString() + ' ' + F.absoluteBoundingBox.height.toString()
                    else
                        '0 0 24 24'  -- default viewBox
                    endif
                ),
                thisModule.CreateAttribute('xmlns', 'http://www.w3.org/2000/svg'),
                thisModule.CreateAttribute('width', 
                    if not F.absoluteBoundingBox.oclIsUndefined() then
                        F.absoluteBoundingBox.width.toString() + 'px'
                    else
                        '24px'
                    endif
                ),
                thisModule.CreateAttribute('height', 
                    if not F.absoluteBoundingBox.oclIsUndefined() then
                        F.absoluteBoundingBox.height.toString() + 'px'
                    else
                        '24px'
                    endif
                )
            },
            children <- if not F.children.oclIsUndefined() then
                F.children->collect(e | thisModule.resolveTemp(e, 'R'))
            else
                Sequence {}
            endif
        )
}

-- rule FigmaFrame2ReactDivHtmlElement {
--     from
--         F : Figma!FRAME(
--             F.isFrame() and 
--             not F.name.toString().toLower().startsWith('form') and
--             not F.isInput() and 
--             not F.isScreen() and 
--             not F.isCheckbox()
--         )
--     to 
--         R : React!HTMLElement (
--             -- Only create an <a> tag if we can find the target canvas
--             name <- if F.hasClickNavigation() and not thisModule.findCanvasById(F.getNavigationDestination()).oclIsUndefined() then 
--                      'a' 
--                     else 
--                      'div' 
--                     endif,
            
--             isSelfClosing <- false,
--             key <- F.id,
            
--             -- Only add href attributes if we have a valid navigation target
--             attributes <- if F.hasClickNavigation() then
--                 let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
--                 if not targetCanvas.oclIsUndefined() then
--                     Sequence {
--                         thisModule.CreateAttribute('href', '/' + thisModule.sanitizeName(targetCanvas.name)),
--                         thisModule.CreateAttribute('style', 'textDecoration: none; color: inherit;')
--                     }
--                 else
--                     -- If no target canvas, use regular frame attributes
--                     Sequence {
--                         thisModule.CreateAttribute('style', F.generateFrameStyles()),
--                         thisModule.CreateAttribute('id', F.id)
--                     }
--                 endif
--             else
--                 Sequence {
--                     thisModule.CreateAttribute('style', F.generateFrameStyles()),
--                     thisModule.CreateAttribute('id', F.id)
--                 }
--             endif,
            
--             -- Only create nested children with a wrapper if we have a valid navigation target
--             children <- if F.hasClickNavigation() then
--                 let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
--                 if not targetCanvas.oclIsUndefined() then
--                     -- For navigation, create a div with the original styles that will be inside the <a> tag
--                     Sequence {
--                         thisModule.CreateNestedElement(F)
--                     }
--                 else
--                     -- If no target canvas, just process children normally
--                     if not F.children.oclIsUndefined() then
--                         F.children->collect(e | thisModule.resolveTemp(e, 'R'))
--                     else
--                         Sequence {}
--                     endif
--                 endif
--             else
--                 if not F.children.oclIsUndefined() then
--                     F.children->collect(e | thisModule.resolveTemp(e, 'R'))
--                 else
--                     Sequence {}
--                 endif
--             endif
--         )
-- }

rule FigmaFrame2ReactDivHtmlElement {
    from
        F : Figma!FRAME(
            F.isFrame() and 
            not F.name.toString().toLower().startsWith('form') and
            not F.isInput() and 
            not F.isScreen() and 
            not F.isCheckbox() and
            not F.isButtonContainer()  -- Add this condition to exclude button frames
        )
    to 
        R : React!HTMLElement (
            -- Only create an <a> tag if we can find the target canvas
            name <- if F.hasClickNavigation() and not thisModule.findCanvasById(F.getNavigationDestination()).oclIsUndefined() then 
                     'a' 
                    else 
                     'div' 
                    endif,
            
            isSelfClosing <- false,
            key <- F.id,
            
            -- Only add href attributes if we have a valid navigation target
            attributes <- if F.hasClickNavigation() then
                let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
                if not targetCanvas.oclIsUndefined() then
                    Sequence {
                        thisModule.CreateAttribute('href', '/' + thisModule.sanitizeName(targetCanvas.name)),
                        thisModule.CreateAttribute('style', 'textDecoration: none; color: inherit;')
                    }
                else
                    -- If no target canvas, use regular frame attributes
                    Sequence {
                        thisModule.CreateAttribute('style', F.generateFrameStyles()),
                        thisModule.CreateAttribute('id', F.id)
                    }
                endif
            else
                Sequence {
                    thisModule.CreateAttribute('style', F.generateFrameStyles()),
                    thisModule.CreateAttribute('id', F.id)
                }
            endif,
            
            -- Only create nested children with a wrapper if we have a valid navigation target
            children <- if F.hasClickNavigation() then
                let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
                if not targetCanvas.oclIsUndefined() then
                    -- For navigation, create a div with the original styles that will be inside the <a> tag
                    Sequence {
                        thisModule.CreateNestedElement(F)
                    }
                else
                    -- If no target canvas, just process children normally
                    if not F.children.oclIsUndefined() then
                        F.children->collect(e | thisModule.resolveTemp(e, 'R'))
                    else
                        Sequence {}
                    endif
                endif
            else
                if not F.children.oclIsUndefined() then
                    F.children->collect(e | thisModule.resolveTemp(e, 'R'))
                else
                    Sequence {}
                endif
            endif
        )
}


helper context Figma!FRAME def : getStyleString() : String =
    -- 'width: ' + self.absoluteBoundingBox.width.toString() + 'px; ' +
    -- 'height: ' + self.absoluteBoundingBox.height.toString() + 'px; ' +
    'display: flex; ' +
    (if not self.backgroundColor.oclIsUndefined() then 
        ' background-color: ' + self.backgroundColor.toRGBA() + ';'
    else 
        ''
    endif);

-- Helper for Color to RGBA
-- helper context Figma!Background def : toRGBA() : String = 'rgba('+self.color.r+','+self.color.g+','+self.color.b+','+self.color.a+')';
-- For Background objects
helper context Figma!Background def : toRGBA() : String =
    if not self.color.oclIsUndefined() then
        self.color.toRGBA()
    else
        'rgba(0, 0, 0, 0)'
    endif;

lazy rule CreateAttribute {
	from
		name : String,
		value : String
	to
		attr: React!HTMLAttribute(
			name <- name,
			value <- value,
			isRequire <- false,
			type <- 'string'
		)
}

rule FigmaRectangle2ReactDivHtmlElement {
    from
        F : Figma!Children(F.isRectangle())
    to 
        R : React!HTMLElement (
            name <- if F.hasClickNavigation() then 'a' else 'div' endif,
            isSelfClosing <- false,
            key <- F.id,
            attributes <- if F.hasClickNavigation() then
                let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
                if not targetCanvas.oclIsUndefined() then
                    Sequence {
                        thisModule.CreateAttribute('href', '/' + thisModule.sanitizeName(targetCanvas.name)),
                        thisModule.CreateAttribute('style', 'textDecoration: none; color: inherit;')
                    }
                else
                    Sequence {}
                endif
            else
                Sequence {
                    thisModule.CreateAttribute('id', F.id)
                }
            endif,
            children <- if F.hasClickNavigation() then
                Sequence {
                    thisModule.CreateNestedElement(F)
                }
            else
                F.children->collect(e | thisModule.resolveTemp(e, 'R'))
            endif
        )
}

rule FigmLine2ReactHrHtmlElement {
	from
		F : Figma!LINE
	to 
		R : React!HTMLElement (
			name <- 'hr',
			isSelfClosing <- true,
			key <- F.id,
			attributes <- Sequence{
				thisModule.CreateAttribute('id',F.id)
			}
		)
}

-- helper context Figma!COMPONENT_SET def : getComponentProps() : Sequence(React!Props) =
--     if self.componentPropertyDefinitions.oclIsUndefined() then
--         Sequence{}
--     else
--         self.componentPropertyDefinitions->collect(entry | 
--             thisModule.CreateComponentProp(
--                 entry.key,
--                 entry.value.type.toString(),
--                 entry.value.defaultValue.toString()
--             )
--         )
--     endif;

helper context Figma!COMPONENT_SET def : getComponentProps() : Sequence(React!Props) =
    -- Create an empty sequence to store the props
    let props : Sequence(React!Props) = Sequence{} in
    
    -- Check if componentPropertyDefinitions exists
    if self.componentPropertyDefinitions.oclIsUndefined() then
        props
    else
        -- Extract all componentPropertyDefinitions
        self.componentPropertyDefinitions->iterate(
            propDef; 
            acc : Sequence(React!Props) = props | 
            
            -- For each property definition, create a prop
            let propName : String = 
                if propDef.key.oclIsUndefined() then
                    'unnamed_prop'
                else
                    propDef.key
                endif
            in
            
            let propType : String = 
                if propDef.componentpropertydefinition.oclIsUndefined() or
                   propDef.componentpropertydefinition.type.oclIsUndefined() then
                    'TEXT'  -- Default type
                else
                    propDef.componentpropertydefinition.type.toString()
                endif
            in
            
            let defaultValue : String = 
                if propDef.componentpropertydefinition.oclIsUndefined() or
                   propDef.componentpropertydefinition.defaultValue.oclIsUndefined() then
                    ''  -- Default empty value
                else
                    propDef.componentpropertydefinition.defaultValue.toString()
                endif
            in
            
            -- Check if we have variant options
            let hasVariants : Boolean = 
                not propDef.componentpropertydefinition.oclIsUndefined() and
                not propDef.componentpropertydefinition.variantOptions.oclIsUndefined() and
                not propDef.componentpropertydefinition.variantOptions->isEmpty()
            in
            
            -- Add the new prop to the accumulator using the appropriate rule
            if hasVariants and propType = 'VARIANT' then
                acc->including(
                    thisModule.CreateComponentPropWithVariants(
                        propName, 
                        propType, 
                        defaultValue, 
                        propDef.componentpropertydefinition.variantOptions
                    )
                )
            else
                acc->including(
                    thisModule.CreateComponentProp(propName, propType, defaultValue)
                )
            endif
        )
    endif;
-- Helper to get instance properties
helper context Figma!INSTANCE def : getComponentProps() : Sequence(React!Props) =
    if self.componentProperties.oclIsUndefined() then
        Sequence{}
    else
        self.componentProperties->collect(entry |
            thisModule.CreateComponentProp(
                entry.key,
                entry.value.type.toString(),
                entry.value.value.toString()
            )
        )
    endif;


-- Helper to safely get PropType enum value
helper def : getPropType(typeStr : String) : React!PropType =
    if typeStr = 'BOOLEAN' then 
        React!PropType.allInstances()->select(e | e.name = 'boolean')->first()
    else if typeStr = 'TEXT' or typeStr = 'VARIANT' then 
        React!PropType.allInstances()->select(e | e.name = 'String')->first()
    else 
        React!PropType.allInstances()->select(e | e.name = 'ANY')->first()
    endif endif;

-- Helper rule to create component props
-- lazy rule CreateComponentProp {
--     from
--         name : String,
--         type : String,
--         defaultValue : String
--     to
--         prop : React!Props (
--             name <- name,
--             value <- 
--                 if type = 'BOOLEAN' then #PropType.boolean
--                 else if type = 'TEXT' then #PropType.String
--                 else if type = 'VARIANT' then #PropType.String
--                 else #PropType.ANY
--                 endif endif endif,
--             defaultValue <- defaultValue,
--             isRequire <- false
--         )
-- }


-- Convert a string to camelCase (e.g., "Show Helper text#258:13" -> "showHelperText")
helper def : toCamelCase(input : String) : String =
    let cleanInput : String = 
        -- Remove any ID suffixes like #258:13
        if input.indexOf('#') > 0 then
            input.substring(1, input.indexOf('#'))
        else
            input
        endif
    in
    let words : Sequence(String) = cleanInput.split(' ') in
    words->iterate(word; result : String = '' |
        if result = '' then
            -- First word starts with lowercase
            word.toLowerCase()
        else
            -- Subsequent words start with uppercase
            result + word.substring(1, 1).toUpper() + 
            if word.size() > 1 then
                word.substring(2, word.size()).toLowerCase()
            else
                ''
            endif
        endif
    );


-- Convert Figma type to React TypeScript type
helper def : figmaTypeToTsType(figmaType : String) : String =
    if figmaType = 'BOOLEAN' then
        'boolean'
    else if figmaType = 'TEXT' then
        'string'
    else if figmaType = 'VARIANT' then
        'string'
    else
        'any'
    endif endif endif;

-- Basic version without variants
lazy rule CreateComponentProp {
    from
        name : String,
        type : String,
        defaultValue : String
    to
        prop : React!Props (
            name <- thisModule.toCamelCase(name),
            -- Keep value for PropType enum
            value <- 
                if type = 'BOOLEAN' then
                    'boolean'
                else if type = 'TEXT' then
                    'String'
                else if type = 'VARIANT' then
                    'String'
                else
                    'ANY'
                endif endif endif,
            defaultValue <- defaultValue,
            isRequire <- false,
            -- Use proper TypeScript type
            type <- thisModule.figmaTypeToTsType(type)
        )
}

-- Extended version with variants
lazy rule CreateComponentPropWithVariants {
    from
        name : String,
        type : String,
        defaultValue : String,
        variants : Sequence(String)
    to
        prop : React!Props (
            name <- thisModule.toCamelCase(name),
            -- For variant types, just use the default value directly
            value <- 
                if type = 'VARIANT' then
                    defaultValue
                else if type = 'BOOLEAN' then
                    'boolean'
                else if type = 'TEXT' then
                    'String'
                else
                    'ANY'
                endif endif endif,
            defaultValue <- defaultValue,
            isRequire <- false,
            -- For variants, create a clean union type like "default"|"secondary"
            type <- 
                if type = 'VARIANT' and not variants->isEmpty() then
                    -- Create a union type without quotes around the values
                    variants->iterate(v; acc : String = '' |
                        if acc = '' then
                            v
                        else
                            acc + '|' + v
                        endif
                    )
                else
                    thisModule.figmaTypeToTsType(type)
                endif
        )
}

-- Helper to convert a component name to PascalCase (e.g., "Input Component" -> "InputComponent")
helper def : toPascalCase(input : String) : String =
    let cleanInput : String = 
        -- Remove any special characters or dashes
        if input.indexOf('-') > 0 then
            input.regexReplaceAll('-', ' ')
        else
            input
        endif
    in
    let words : Sequence(String) = cleanInput.split(' ') in
    words->iterate(word; result : String = '' |
        if word.size() > 0 then
            -- Capitalize first letter of each word
            result + word.substring(1, 1).toUpper() + 
            if word.size() > 1 then
                word.substring(2, word.size())
            else
                ''
            endif
        else
            result
        endif
    );

-- Updated rule for component sets
rule FigmaComponentSet2ReactComponent {
    from
        F : Figma!Children(F.isComponentSet())
    to 
        R : React!Component (
            name <- thisModule.toPascalCase(F.name),
            key <- F.id,
            props <- F.getComponentProps(),
            children <- Sequence{
                thisModule.CreateComponentWrapper(F)
            },
            isInstance <- false
        )
}


-- Helper rule to create a wrapper div with the styles
lazy rule CreateComponentWrapper {
    from
        F : Figma!COMPONENT_SET
    to
        R : React!HTMLElement (
            name <- 'div',
            attributes <- Sequence {
                thisModule.CreateAttribute('style', F.generateFrameStyles())
            },
            children <- if not F.children.oclIsUndefined() then
                F.children->collect(e | thisModule.resolveTemp(e, 'R'))
            else
                Sequence {}
            endif
        )
}

-- Helper to get instance properties with their actual values
helper context Figma!INSTANCE def : getInstanceProps() : Sequence(React!Props) =
    if self.componentProperties.oclIsUndefined() then
        Sequence{}
    else
        -- Extract the actual properties with their values
        self.componentProperties->collect(propDef |
            let propName : String = 
                if propDef.key.oclIsUndefined() then
                    'unnamed_prop'
                else
                    propDef.key
                endif
            in
            
            let propType : String = 
                if propDef.value.oclIsUndefined() or
                   propDef.value.type.oclIsUndefined() then
                    'TEXT'  -- Default type
                else
                    propDef.value.type.toString()
                endif
            in
            
            let propValue : String = 
                if propDef.value.oclIsUndefined() or
                   propDef.value.value.oclIsUndefined() then
                    ''  -- Default empty value
                else
                    propDef.value.value.toString()
                endif
            in
            
            -- Create prop with the actual value
            thisModule.CreateInstanceProp(
                thisModule.toCamelCase(propName),
                propType,
                propValue
            )
        )
    endif;

-- Specialized lazy rule for instance properties
lazy rule CreateInstanceProp {
    from
        name : String,
        type : String,
        value : String
    to
        prop : React!Props (
            name <- name,
            -- For boolean values, convert string to actual boolean if needed
            value <- 
                if type = 'BOOLEAN' then
                    if value = 'True' or value = 'true' then
                        'true'
                    else
                        'false'
                    endif
                else
                    value
                endif,
            defaultValue <- value,  -- Use the actual value as default too
            isRequire <- false,
            type <- thisModule.figmaTypeToTsType(type)
        )
}

-- Updated rule for instances
rule FigmaInstance2ReactComponent {
    from
        F : Figma!Children(F.isInstance())
    to 
        R : React!Component (
            name <- thisModule.toPascalCase(F.name),
            key <- F.id,
            props <- F.getInstanceProps(),
            children <- if not F.children.oclIsUndefined() then
                Sequence {
                    thisModule.CreateStyledWrapper(F)
                }
            else
                Sequence {}
            endif,
            isInstance <- true
        )
}

-- Helper rule to create a styled wrapper div for instances
lazy rule CreateStyledWrapper {
    from
        F : Figma!INSTANCE
    to
        R : React!HTMLElement (
            name <- 'div',
            key <- F.id + '_wrapper',
            isSelfClosing <- false,
            attributes <- Sequence {
                thisModule.CreateAttribute('style', F.generateFrameStyles())
            },
            children <- if not F.children.oclIsUndefined() then
                F.children->collect(e | thisModule.resolveTemp(e, 'R'))
            else
                Sequence {}
            endif
        )
}


rule FigmaComponent2RectDivHtmlElement {
	from
		F : Figma!COMPONENT
	to 
		R : React!HTMLElement (
			name<-'div',
			children <- if not F.children.oclIsUndefined() then
                F.children->collect(e | thisModule.resolveTemp(e, 'R'))
            else
                Sequence {}
            endif,
			attributes <- Sequence{
				thisModule.CreateAttribute('id',F.id)
			}
		)
}

helper context Figma!TEXT def : isLabel() : Boolean = 
	if self.name.toString().toLower().startsWith('label') then
		true
	else
		false		
	endif;

helper context Figma!TEXT def : isPlaceholder() : Boolean = 
	if self.name.toString().toLower().startsWith('placeholder') then
		true
	else
		false
	endif;


helper context Figma!TEXT def : isParagraph() : Boolean = 
	if self.name.toString().toLower().startsWith('p') then
		true
	else
		false
	endif;

helper context Figma!TEXT def : isButton() : Boolean = 
	if self.name.toString().toLower().startsWith('button') then
		true
	else
		false
	endif;


helper context Figma!TEXT def : getTextTag(): String =
    if self.name.toString().toLower().startsWith('label') then
        'label'
    else 
        if self.name.toString().toLower().startsWith('p') then
            'p'
        else 
            if self.name.toString().toLower().startsWith('small') then
                'small'
            else 
                if self.name.toString().toLower().startsWith('h1') then
                    'h1'
                else 
                    if self.name.toString().toLower().startsWith('h2') then
                        'h2'
                    else 
                        if self.name.toString().toLower().startsWith('h3') then
                            'h3'
                        else 
                            if self.name.toString().toLower().startsWith('h4') then
                                'h4'
                            else 
                                if self.name.toString().toLower().startsWith('h5') then
                                    'h5'
                                else 
                                    if self.name.toString().toLower().startsWith('h6') then
                                        'h6'
                                    else 
                                        if self.name.toString().toLower().startsWith('span') then
                                            'span'
                                        else 
                                            if not self.style.oclIsUndefined() then
                                                if self.style.fontSize >= 40 then
                                                    'h1'
                                                else 
                                                    if self.style.fontSize >= 32 then
                                                        'h2'
                                                    else 
                                                        if self.style.fontSize >= 28 then
                                                            'h3'
                                                        else 
                                                            if self.style.fontSize >= 24 then
                                                                'h4'
                                                            else 
                                                                if self.style.fontSize >= 20 then
                                                                    'h5'
                                                                else 
                                                                    if self.style.fontSize >= 16 then
                                                                        'h6'
                                                                    else 
                                                                        if self.style.fontSize <= 12 then
                                                                            'small'
                                                                        else 
                                                                            'p'
                                                                        endif
                                                                    endif
                                                                endif
                                                            endif
                                                        endif
                                                    endif
                                                endif
                                            else
                                                'p'
                                            endif
                                        endif
                                    endif
                                endif
                            endif
                        endif
                    endif
                endif
            endif
        endif
    endif;


-- First, let's make the helper more robust
-- helper context Figma!FRAME def : isInput() : Boolean =
--     if self.type.toString() = 'FRAME' and  -- Make sure it's a Frame
--        self.name.toString().toLowerCase().startsWith('input') and  -- Check name
--        not self.children.isEmpty() and  -- Has children
--        self.children->exists(c |  -- Has placeholder text
--             c.type.toString() = 'TEXT' and 
--             c.name.toLowerCase().startsWith('placeholder')
--         )
--     then
--         true
--     else
--         false
--     endif;

helper context Figma!FRAME def : isInput() : Boolean =
    if self.type.toString() = 'FRAME' and
       not self.name.oclIsUndefined() and
       self.name.toString().toLowerCase().startsWith('input') and
       not self.children.oclIsUndefined() and
       not self.children->isEmpty() and
       self.children->exists(c |
           not c.oclIsUndefined() and
           c.type.toString() = 'TEXT' and
           not c.name.oclIsUndefined() and
           c.name.toString().toLowerCase().startsWith('placeholder')
       )
    then
        true
    else
        false
    endif;


-- Helper to get placeholder text
helper context Figma!FRAME def : getPlaceholderText() : Figma!Children =
    if not self.children.isEmpty() then
        self.children->select(c | 
            c.type.toString() = 'TEXT' and 
            c.name.toLowerCase().startsWith('placeholder')
        )->first()
    else
        OclUndefined
    endif;


-- Add this helper to print debug info
helper def : debugFrame(frame : Figma!FRAME) : String = 
    let debugInfo : String = frame.debugIsInput() in
    frame.name + ' debug info: ' + debugInfo;


helper context Figma!FRAME def : debugIsInput() : String =
    'Frame type: ' + self.type.toString() + ', ' +
    'Name: ' + self.name.toString() + ', ' +
    'Has children: ' + (not self.children.isEmpty()).toString() + ', ' +
    'Has placeholder: ' + (self.children->exists(c | 
        c.type.toString() = 'TEXT' and 
        c.name.toLowerCase().startsWith('placeholder')
    )).toString();

-- rule FigmaFrame2Input {
--    from
--        F : Figma!FRAME (F.isInput())
--    using {
--        placeholderText : Figma!Children = F.getPlaceholderText();
--        styleString : String =
--            '{' +
--            (if not F.absoluteBoundingBox.oclIsUndefined() then
--                'width: ' + F.absoluteBoundingBox.width.toString() + 'px, ' +
--                'height: ' + F.absoluteBoundingBox.height.toString() + 'px, '
--            else
--                ''
--            endif) +
--            'padding: 8px 12px, ' +
--            'border: 1px solid #ccc, ' +
--            (if not F.cornerRadius.oclIsUndefined() then
--                'borderRadius: ' + F.cornerRadius.toString() + 'px, '
--            else
--                'borderRadius: 4px, '
--            endif) +
--            (if not F.backgroundColor.oclIsUndefined() then
--                'backgroundColor: "' + F.backgroundColor.toRGBA() + '", '
--            else
--                ''
--            endif) +
--            (if not placeholderText.oclIsUndefined() and not placeholderText.style.oclIsUndefined() then
--                placeholderText.style.toStyleString().substring(2, placeholderText.style.toStyleString().size() - 1) + ''
--            else
--                ''
--            endif) +
--            '}';
--    }
--    to
--        R : React!HTMLElement (
--            name <- 'input',
--            key <- F.id,
--            isSelfClosing <- true,
--            attributes <- Sequence {
--                thisModule.CreateAttribute('style', styleString),
--                thisModule.CreateAttribute('type', 'text'),
--                thisModule.CreateAttribute('placeholder',
--                    if not placeholderText.oclIsUndefined() then
--                        placeholderText.characters
--                    else
--                        ''
--                    endif
--                ),
--                thisModule.CreateAttribute('id', F.id)
--            }
--        )
-- }

rule FigmaFrame2Input {
   from
       F : Figma!FRAME (F.isInput())
   using {
       placeholderText : Figma!Children = F.getPlaceholderText();
       
       -- Create a professional style string based on the frame attributes
       styleString : String =
           '{' +
           -- Use explicit padding values from the frame if available
           (if not F.paddingLeft.oclIsUndefined() or not F.paddingRight.oclIsUndefined() or 
               not F.paddingTop.oclIsUndefined() or not F.paddingBottom.oclIsUndefined() then
               'padding: "' + 
               (if not F.paddingTop.oclIsUndefined() then F.paddingTop.toString() else '8' endif) + 'px ' +
               (if not F.paddingRight.oclIsUndefined() then F.paddingRight.toString() else '12' endif) + 'px ' +
               (if not F.paddingBottom.oclIsUndefined() then F.paddingBottom.toString() else '8' endif) + 'px ' +
               (if not F.paddingLeft.oclIsUndefined() then F.paddingLeft.toString() else '12' endif) + 'px", '
           else if not F.itemSpacing.oclIsUndefined() then
               -- Use itemSpacing as fallback
               'padding: "' + F.itemSpacing.toString() + 'px", ' 
           else
               'padding: "8px 12px", '  -- Default padding
           endif endif) +
           
           -- Border styling from strokes
           (if not F.strokes.oclIsUndefined() and not F.strokes->isEmpty() and not F.strokeWeight.oclIsUndefined() then
               'border: "' + F.strokeWeight.toString() + 'px solid ' + F.strokes->first().color.toRGBA() + '", '
           else
               'border: "1px solid #ccc", '  -- Default border
           endif) +
           
           -- Corner radius from frame
           (if not F.cornerRadius.oclIsUndefined() then
               'borderRadius: "' + F.cornerRadius.toString() + 'px", '
           else
               'borderRadius: "4px", '
           endif) +
           
           -- Background color
           (if not F.backgroundColor.oclIsUndefined() then
               'backgroundColor: "' + F.backgroundColor.toRGBA() + '", '
           else
               'backgroundColor: "rgba(0, 0, 0, 0.0)", '  -- Transparent background
           endif) +
           
           -- Layout mode styles
           (if not F.layoutMode.oclIsUndefined() and F.layoutMode.toString() = 'HORIZONTAL' then
               'display: "flex", flexDirection: "row", '
           else
               ''
           endif) +
           
           -- Alignment styles
           (if not F.counterAxisAlignItems.oclIsUndefined() then
               'alignItems: "' + 
               (if F.counterAxisAlignItems.toString() = 'CENTER' then 'center'
                else if F.counterAxisAlignItems.toString() = 'MIN' then 'flex-start'
                else if F.counterAxisAlignItems.toString() = 'MAX' then 'flex-end'
                else 'stretch'
                endif endif endif) + '", '
           else
               ''
           endif) +
           
           -- Font styling from placeholder text or defaults
           (if not placeholderText.oclIsUndefined() and not placeholderText.style.oclIsUndefined() then
               (if not placeholderText.style.fontFamily.oclIsUndefined() then
                   'fontFamily: "' + placeholderText.style.fontFamily + '", '
               else
                   'fontFamily: "Inter", '  -- Default from example
               endif) +
               (if not placeholderText.style.fontSize.oclIsUndefined() then
                   'fontSize: "' + placeholderText.style.fontSize + 'px", '
               else
                   'fontSize: "24.0px", '  -- Default from example
               endif) +
               (if not placeholderText.style.fontWeight.oclIsUndefined() then
                   'fontWeight: ' + placeholderText.style.fontWeight + ', '
               else
                   'fontWeight: 400, '  -- Default from example
               endif) +
               (if not placeholderText.style.letterSpacing.oclIsUndefined() then
                   'letterSpacing: "' + placeholderText.style.letterSpacing + 'px", '
               else
                   'letterSpacing: "0.0px", '  -- Default from example
               endif) +
               (if not placeholderText.style.lineHeightPx.oclIsUndefined() then
                   'lineHeight: "' + placeholderText.style.lineHeightPx + 'px"'
               else
                   'lineHeight: "29.045454px"'  -- Default from example
               endif)
           else
               -- Default styling from example if no placeholder text available
               'fontFamily: "Inter", ' +
               'fontSize: "24.0px", ' +
               'fontWeight: 400, ' +
               'letterSpacing: "0.0px", ' +
               'lineHeight: "29.045454px"'
           endif) +
           '}';
   }
   to
       R : React!HTMLElement (
           name <- 'input',
           key <- F.id,
           isSelfClosing <- true,
           attributes <- Sequence {
               thisModule.CreateAttribute('style', styleString),
               thisModule.CreateAttribute('type', 'text'),
               thisModule.CreateAttribute('placeholder',
                   if not placeholderText.oclIsUndefined() then
                       placeholderText.characters
                   else
                       ''
                   endif
               ),
               thisModule.CreateAttribute('id', F.id)
           }
       )
}

-- Helper to convert text style to CSS string
helper context Figma!Style def : toStyleString() : String =
   '{' +
   'fontFamily: "' + self.fontFamily + '", ' +
   'fontSize: "' + self.fontSize.toString() + 'px", ' +
   'fontWeight: "' + self.fontWeight.toString() + '", ' +
   'letterSpacing: "' + self.letterSpacing.toString() + 'px", ' +
   'lineHeight: "' + 
   (if self.lineHeightUnit.toString() = 'INTRINSIC_' then 
       self.lineHeightPx 
   else 
       self.lineHeightPercent 
   endif).toString() + 'px"' +
   '}';


-- rule Figma2Button {
--     from
--         F : Figma!TEXT(F.isButton())
--     to 
--         R : React!HTMLElement (
--             name <- if F.hasClickNavigation() then 'a' else 'button' endif,
--             key <- F.id,
--             isSelfClosing <- false,
--             content <- if F.hasClickNavigation() then 
--                 OclUndefined 
--             else 
--                 F.characters
--             endif,
--             attributes <- if F.hasClickNavigation() then
--                 let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
--                 if not targetCanvas.oclIsUndefined() then
--                     Sequence {
--                         thisModule.CreateAttribute('href', '/' + thisModule.sanitizeName(targetCanvas.name)),
--                         thisModule.CreateAttribute('style', 'textDecoration: none; color: inherit;')
--                     }
--                 else
--                     Sequence {

--                 	}
--                 endif
--             else
--                 Sequence {}
--             endif,
--             children <- if F.hasClickNavigation() then
--                 Sequence {
--                     thisModule.CreateNestedTextElement(F)
--                 }
--             else
--                 Sequence {}
--             endif
--         )
-- }

rule FigmaFrame2Form{
    from
        F: Figma!FRAME(F.isFrame() and F.name.toString().toLower().startsWith('form')  and not F.isScreen())
    to
        R: React!HTMLElement(
            name <- 'form',
            key <- F.id,
            isSelfClosing <- false,
            attributes <- Sequence{
                thisModule.CreateAttribute('id',F.id),
                thisModule.CreateAttribute('style',F.generateFrameStyles()),
                -- Set method to POST by default
                thisModule.CreateAttribute('method','POST')
            },
            children <- if not F.children.oclIsUndefined() then
                F.children->collect(e | thisModule.resolveTemp(e, 'R'))
            else
                Sequence {}
            endif
        )
}

rule FigmaFrame2Checkbox{
    from
        F: Figma!FRAME(F.isFrame() and F.name.toString().toLower().indexOf('checkbox') <> -1)
    to
        R: React!HTMLElement(
            name <- 'input',
            key <- F.id,
            isSelfClosing <- true,
            attributes <- Sequence{
                thisModule.CreateAttribute('id',F.id),
                thisModule.CreateAttribute('type','checkbox'),
                thisModule.CreateAttribute('style',F.generateFrameStyles())
            }
        )
}


rule FigmaText2ReactDisplaylHtmlElement {
    from
        F : Figma!TEXT(not F.isPlaceholder() and not F.isButton())
    to 
        R : React!HTMLElement(
            -- Only create an <a> tag if hasClickNavigation AND we can find the target canvas
            name <- if F.hasClickNavigation() and not thisModule.findCanvasById(F.getNavigationDestination()).oclIsUndefined() then 
                     'a' 
                    else 
                     F.getTextTag() 
                    endif,
            
            -- Content handling depends on whether we created an <a> tag
            content <- if F.hasClickNavigation() and not thisModule.findCanvasById(F.getNavigationDestination()).oclIsUndefined() then 
                        OclUndefined 
                       else 
                        F.characters 
                       endif,
            
            isSelfClosing <- false,
            
            -- Only add href attributes if we have a valid navigation target
            attributes <- if F.hasClickNavigation() then
                let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
                if not targetCanvas.oclIsUndefined() then
                    Sequence {
                        thisModule.CreateAttribute('href', '/' + thisModule.sanitizeName(targetCanvas.name)),
                        thisModule.CreateAttribute('style', 'text-decoration: none;')
                    }
                else
                    -- If no target, don't add any attributes (regular text element attributes will apply)
                    Sequence {}
                endif
            else
                -- Regular styling for text without navigation
                Sequence {
                   thisModule.CreateAttribute('style', 
                    F.generateTextStyles()) 
                }
            endif,
            
            -- Only create nested children if we have a valid navigation target
            children <- if F.hasClickNavigation() then
                let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
                if not targetCanvas.oclIsUndefined() then
                    -- Use the nested text element rule to create a proper child
                    Sequence {
                        thisModule.CreateNestedTextElement(F)
                    }
                else
                    -- If no target canvas, just return any children directly
                    if not F.children.oclIsUndefined() then
                        F.children->collect(e | thisModule.resolveTemp(e, 'R'))
                    else
                        Sequence {}
                    endif
                endif
            else
                -- Handle regular children if any
                if not F.children.oclIsUndefined() then
                    F.children->collect(e | thisModule.resolveTemp(e, 'R'))
                else
                    Sequence {}
                endif
            endif
        )
}

-- Frame styles helper

-- Helper to convert color to RGBA string

-- For Color objects
helper context Figma!Color def : toRGBA() : String =
    'rgba(' +
    (if not self.r.oclIsUndefined() then (self.r * 255).round().toString() else '0' endif) + ', ' +
    (if not self.g.oclIsUndefined() then (self.g * 255).round().toString() else '0' endif) + ', ' +
    (if not self.b.oclIsUndefined() then (self.b * 255).round().toString() else '0' endif) + ', ' +
    (if not self.a.oclIsUndefined() then self.a.toString() else '1' endif) + ')';

-- Comprehensive helper that handles all element types safely
helper context Figma!Children def : getBackgroundColor() : String =
    -- Check the specific element type and handle accordingly
    if self.oclIsTypeOf(Figma!TEXT) then
        'transparent'  -- Default for TEXT elements
    else if self.oclIsTypeOf(Figma!INSTANCE) then
        'transparent'  -- Default for INSTANCE elements
    else if self.oclIsTypeOf(Figma!RECTANGLE) then
        -- Handle RECTANGLE elements which don't have backgroundColor property
        if not self.fills.oclIsUndefined() then
            if not self.fills.color.oclIsUndefined() then
                self.fills.color.toRGBA()
            else
                'transparent'
            endif
        else
            'transparent'
        endif
    else if not self.backgroundColor.oclIsUndefined() then
        self.backgroundColor.toRGBA()  -- Use backgroundColor when available for other types
    else
        'transparent'  -- Default fallback
    endif endif endif endif;

-- Helper to build flexbox styles from frame layout properties
helper context Figma!FRAME def : getFlexStyles() : String =
    let layoutModeStyle : String = 
        if self.layoutMode.toString() = 'HORIZONTAL' then
            'flexDirection: "row"'
        else
            'flexDirection: "column"'
        endif
    in
    let alignItemsStyle : String =
        if not self.counterAxisAlignItems.oclIsUndefined() then
            if self.counterAxisAlignItems.toString() = 'CENTER' then
                ', alignItems: "center"'
            else
                ''
            endif
        else
            ''
        endif
    in
    let gapStyle : String =
        if not self.itemSpacing.oclIsUndefined() then
            ', gap: "' + self.itemSpacing.toString() + 'px"'
        else
            ''
        endif
    in
    let layoutWrapStyle : String =
        if not self.layoutWrap.oclIsUndefined() and self.layoutWrap.toString() = 'NO_WRAP' then
            ', flexWrap: "nowrap"'
        else
            ''
        endif
    in
    layoutModeStyle + alignItemsStyle + gapStyle + layoutWrapStyle;

-- Helper to check if element needs frame styles
helper context Figma!Children def : needsFrameStyles() : Boolean =
    self.isFrame() or self.isComponent() or self.isInstance() or self.isComponentSet();


helper context Figma!Children def : generateFrameStyles() : String =
    -- Use different style generation based on element type
    if self.oclIsTypeOf(Figma!RECTANGLE) then
        -- RECTANGLE specific styling (avoid accessing properties that don't exist)
        let backgroundColor : String = 
            if not self.fills.oclIsUndefined() and not self.fills.color.oclIsUndefined() then
                self.fills.color.toRGBA()
            else
                'transparent'
            endif
        in
        let dimensions : String =
            if not self.absoluteBoundingBox.oclIsUndefined() then
                'width: ' + self.absoluteBoundingBox.width.toString() + 'px, ' +
                'height: ' + self.absoluteBoundingBox.height.toString() + 'px'
            else
                ''
            endif
        in
        '{display: flex, flexDirection: column' + 
        (if dimensions <> '' then ', ' + dimensions else '' endif) +
        ', backgroundColor: "' + backgroundColor + '"}'
    
    else if self.oclIsTypeOf(Figma!TEXT) then
        -- TEXT specific styling
        let dimensions : String =
            if not self.absoluteBoundingBox.oclIsUndefined() then
                'width: ' + self.absoluteBoundingBox.width.toString() + 'px, ' +
                'height: ' + self.absoluteBoundingBox.height.toString() + 'px'
            else
                ''
            endif
        in
        '{display: flex, flexDirection: column' + 
        (if dimensions <> '' then ', ' + dimensions else '' endif) +
        ', backgroundColor: "transparent"}'
    
    else if self.oclIsTypeOf(Figma!INSTANCE) then
        -- INSTANCE specific styling
        let dimensions : String =
            if not self.absoluteBoundingBox.oclIsUndefined() then
                'width: ' + self.absoluteBoundingBox.width.toString() + 'px, ' +
                'height: ' + self.absoluteBoundingBox.height.toString() + 'px'
            else
                ''
            endif
        in
        '{display: flex, flexDirection: column' + 
        (if dimensions <> '' then ', ' + dimensions else '' endif) +
        ', backgroundColor: "transparent"}'
    
    else if self.oclIsTypeOf(Figma!FRAME) then
        -- FRAME specific styling with all its properties
        let backgroundColor : String = 
            if not self.backgroundColor.oclIsUndefined() then
                self.backgroundColor.toRGBA()
            else
                'transparent'
            endif
        in
        let dimensions : String =
            if not self.absoluteBoundingBox.oclIsUndefined() then
                'width: ' + self.absoluteBoundingBox.width.toString() + 'px, ' +
                'height: ' + self.absoluteBoundingBox.height.toString() + 'px'
            else
                ''
            endif
        in
        let flexDirection : String =
            if not self.layoutMode.oclIsUndefined() then
                if self.layoutMode.toString() = 'HORIZONTAL' then
                    'flexDirection: row'
                else
                    'flexDirection: column'
                endif
            else
                'flexDirection: column'
            endif
        in
        let alignItems : String =
            if not self.counterAxisAlignItems.oclIsUndefined() and
               self.counterAxisAlignItems.toString() = 'CENTER' then
                ', alignItems: center'
            else
                ''
            endif
        in
        let gap : String =
            if not self.itemSpacing.oclIsUndefined() then
                ', gap: ' + self.itemSpacing.toString() + 'px'
            else
                ''
            endif
        in
        let flexWrap : String =
            if not self.layoutWrap.oclIsUndefined() and 
               self.layoutWrap.toString() = 'NO_WRAP' then
                ', flexWrap: nowrap'
            else
                ''
            endif
        in
        let borderRadius : String =
            if not self.cornerRadius.oclIsUndefined() then
                ', borderRadius: ' + self.cornerRadius.toString() + 'px'
            else
                ''
            endif
        in
        '{display: flex, ' + 
        flexDirection +
        (if dimensions <> '' then ', ' + dimensions else '' endif) +
        ', backgroundColor: "' + backgroundColor + '"' +
        alignItems +
        gap +
        flexWrap +
        borderRadius +
        '}'
    
    else
        -- Default styling for any other element type
        '{display: flex, flexDirection: column, backgroundColor: "transparent"}'
    
    endif endif endif endif;

-- Helper to find a Canvas by ID in the entire document
helper def : findCanvasById(id : String) : Figma!Children =
    if id = '' then
        OclUndefined
    else
        let allCanvases : Sequence(Figma!Children) = 
            Figma!Children.allInstances()->select(c | 
                c.isCanvas() and not c.id.oclIsUndefined()
            )
        in
        let matchingCanvas : Figma!Children = 
            allCanvases->select(c | c.id = id)->first()
        in
        matchingCanvas
    endif;

-- Helper to check if an element has click navigation
helper context Figma!Children def : hasClickNavigation() : Boolean =
    if self.interactions.oclIsUndefined() or self.interactions->isEmpty() then
        false
    else
        self.interactions->exists(i | 
            not i.trigger.oclIsUndefined() and 
            i.trigger.type = 'ON_CLICK' and
            not i.actions.oclIsUndefined() and 
            not i.actions->isEmpty() and
            i.actions->exists(a | 
                not a.navigation.oclIsUndefined() and
                a.navigation = 'NAVIGATE' and
                not a.destinationId.oclIsUndefined() and
                a.destinationId <> ''
            )
        )
    endif;

-- Helper to get navigation destination
helper context Figma!Children def : getNavigationDestination() : String =
    let clickInteraction : Figma!Interaction = 
        self.interactions->select(i | 
            not i.trigger.oclIsUndefined() and 
            i.trigger.type.toString() = 'ON_CLICK'
        )->first()
    in
    if clickInteraction.oclIsUndefined() then
        ''
    else
        let navigateAction : Figma!Action = 
            clickInteraction.actions->select(a | 
                a.navigation.toString() = 'NAVIGATE'
            )->first()
        in
        if navigateAction.oclIsUndefined() then
            ''
        else
            navigateAction.destinationId
        endif
    endif;
    


    
-- Helper rule to create a nested element (preserving the original element)


--lazy rule CreateNestedElement {
--    from
--        F : Figma!Children
--    to
--        R : React!HTMLElement (
--            name <- thisModule.toPascalCase(F.name),
--            children <- F.children
--        )
--}


--lazy rule CreateNestedTextElement {
--    from
--        F : Figma!Children
--    to
--        R : React!HTMLElement (
--            name <- thisModule.toPascalCase(F.name),
--            children <- F.children
--        )
--}

-- Helper rule to create a nested element for navigation
-- Generic nested element for frames and rectangles with navigation
lazy rule CreateNestedElement {
    from
        F : Figma!Children
    to
        R : React!HTMLElement (
            -- Preserve the original element type (div for FRAME and RECTANGLE)
            name <- 'div',
            isSelfClosing <- false,
            key <- F.id + '_inner',
            -- Preserve the original styling
            attributes <- Sequence {
                thisModule.CreateAttribute('style', F.generateFrameStyles())
            },
            -- Maintain the children
            children <- if not F.children.oclIsUndefined() then
                F.children->collect(e | thisModule.resolveTemp(e, 'R'))
            else
                Sequence {}
            endif
        )
}


-- Helper rule for text elements specifically
-- For text elements with navigation links: create proper nested elements
lazy rule CreateNestedTextElement {
    from
        F : Figma!TEXT
    to
        R : React!HTMLElement (
            -- Preserve the original text tag type (h1, p, etc.)
            name <- F.getTextTag(),
            key <- F.id + '_inner',
            -- Keep the original text content
            content <- F.characters,
            isSelfClosing <- false,
            -- Apply original Figma styles with inheritance for navigation context
            attributes <- Sequence {
                thisModule.CreateAttribute('style', 
                    F.generateTextStyles() + '; color: inherit; text-decoration: inherit;')
            }
        )
}

-- For button elements with navigation links
lazy rule CreateNestedButtonElement {
    from
        F : Figma!TEXT(F.isButton())
    to
        R : React!HTMLElement (
            -- Keep it as a button
            name <- 'button',
            key <- F.id + '_inner',
            content <- F.characters,
            isSelfClosing <- false,
            -- Apply original Figma button styles
            attributes <- Sequence {
                thisModule.CreateAttribute('style', 
                    F.generateTextStyles() + '; cursor: pointer;')
            }
        )
}



-- helper context Figma!TEXT def : generateTextStyles() : String =
--     -- Start with an empty string
--     let baseStyles : String = 'display: inline-block' in
--     let fontStyles : String =
--         if not self.style.oclIsUndefined() then
--             -- Font Family
--             (if not self.style.fontFamily.oclIsUndefined() then
--                 baseStyles + ', fontFamily: "' + self.style.fontFamily + '"'
--              else
--                 baseStyles
--              endif) +
             
--             -- Font Size
--             (if not self.style.fontSize.oclIsUndefined() then
--                 ', fontSize: "' + self.style.fontSize + 'px"'
--              else
--                 ''
--              endif) +
             
--             -- Font Weight
--             (if not self.style.fontWeight.oclIsUndefined() then
--                 ', fontWeight: ' + self.style.fontWeight
--              else
--                 ''
--              endif) +
             
--             -- Letter Spacing
--             (if not self.style.letterSpacing.oclIsUndefined() then
--                 ', letterSpacing: "' + self.style.letterSpacing + 'px"'
--              else
--                 ''
--              endif) +
             
--             -- Line Height
--             (if not self.style.lineHeightPx.oclIsUndefined() then
--                 ', lineHeight: "' + self.style.lineHeightPx + 'px"'
--              else
--                 ''
--              endif) +
             
--             -- Text Alignment Horizontal
--             (if not self.style.textAlignHorizontal.oclIsUndefined() then
--                 ', textAlign: "' + self.style.textAlignHorizontal.toString().toLowerCase() + '"'
--              else
--                 ''
--              endif) +
             
--             -- Text Alignment Vertical
--             (if not self.style.textAlignVertical.oclIsUndefined() then
--                 ', verticalAlign: "' + self.style.textAlignVertical.toString().toLowerCase() + '"'
--              else
--                 ''
--              endif)
--         else
--             baseStyles
--         endif
--     in
--     fontStyles;

-- Helper to generate proper React text styles - only adding properties that have values
helper context Figma!TEXT def : generateTextStyles() : String =
    let baseStyle : String = 'display: "flex"' in
    
    -- Font properties
    let fontStyles : String = 
        (if not self.style.oclIsUndefined() and not self.style.fontFamily.oclIsUndefined() and self.style.fontFamily.size() > 0 then 
            ', fontFamily: "' + self.style.fontFamily + '"' 
        else 
            '' 
        endif) +
        (if not self.style.oclIsUndefined() and not self.style.fontPostScriptName.oclIsUndefined() and self.style.fontPostScriptName.size() > 0 then 
            ', fontPostScriptName: "' + self.style.fontPostScriptName + '"' 
        else 
            '' 
        endif) +
        (if not self.style.oclIsUndefined() and not self.style.fontSize.oclIsUndefined() then 
            ', fontSize: "' + self.style.fontSize + 'px"' 
        else 
            '' 
        endif) +
        (if not self.style.oclIsUndefined() and not self.style.fontWeight.oclIsUndefined() then 
            ', fontWeight: ' + self.style.fontWeight 
        else 
            '' 
        endif)
    in
    
    -- Text layout
    let textLayoutStyles : String = 
        (if not self.style.oclIsUndefined() and not self.style.letterSpacing.oclIsUndefined() then 
            ', letterSpacing: "' + self.style.letterSpacing + 'px"'
        else 
            '' 
        endif) +
        (if not self.style.oclIsUndefined() and not self.style.lineHeightPx.oclIsUndefined() then 
            ', lineHeight: "' + self.style.lineHeightPx + 'px"'
        else if not self.style.oclIsUndefined() and not self.style.lineHeightPercent.oclIsUndefined() then
            ', lineHeight: "' + self.style.lineHeightPercent + '%"'
        else 
            '' 
        endif endif) +
        (if not self.style.oclIsUndefined() and not self.style.textAlignHorizontal.oclIsUndefined() then 
            ', textAlign: "' + 
            (if self.style.textAlignHorizontal.toString() = 'CENTER' then 
                'center'
            else if self.style.textAlignHorizontal.toString() = 'LEFT' then
                'left'
            else if self.style.textAlignHorizontal.toString() = 'RIGHT' then
                'right'
            else if self.style.textAlignHorizontal.toString() = 'JUSTIFIED' then
                'justify'
            else
                'left'
            endif endif endif endif) + '"'
        else 
            '' 
        endif) +
        (if not self.style.oclIsUndefined() and not self.style.textAlignVertical.oclIsUndefined() then 
            ', verticalAlign: "' + 
            (if self.style.textAlignVertical.toString() = 'CENTER' then 
                'middle'
            else if self.style.textAlignVertical.toString() = 'TOP' then
                'top'
            else if self.style.textAlignVertical.toString() = 'BOTTOM' then
                'bottom'
            else
                'baseline'
            endif endif endif) + '"'
        else 
            '' 
        endif)
    in
    
    -- Text auto resize
    let textResizeStyles : String = 
        (if not self.style.oclIsUndefined() and not self.style.textAutoResize.oclIsUndefined() then 
            (if self.style.textAutoResize.toString() = 'WIDTH_AND_HEIGHT' then 
                ', whiteSpace: "normal", width: "fit-content", height: "fit-content"'
            else if self.style.textAutoResize.toString() = 'HEIGHT' then
                ', whiteSpace: "normal", height: "fit-content"'
            else if self.style.textAutoResize.toString() = 'NONE' then
                ', overflow: "hidden"'
            else
                ''
            endif endif endif)
        else 
            '' 
        endif)
    in
    
    -- Text color
    let colorStyles : String = 
        (if not self.fills.oclIsUndefined() and not self.fills.color.oclIsUndefined() then 
            ', color: "' + self.fills.color.toRGBA() + '"'
        else 
            '' 
        endif)
    in
    
    -- Layout properties (specific to text)
    let layoutStyles : String = 
        (if not self.layoutAlign.oclIsUndefined() then
            ', alignSelf: "' + 
            (if self.layoutAlign.toString() = 'STRETCH' then 
                'stretch'
            else if self.layoutAlign.toString() = 'CENTER' then 
                'center'
            else if self.layoutAlign.toString() = 'INHERIT' then 
                'inherit'
            else
                'auto'
            endif endif endif) + '"'
        else
            ''
        endif) +
        (if not self.layoutGrow.oclIsUndefined() then
            ', flexGrow: ' + self.layoutGrow.toString()
        else
            ''
        endif) +
        (if not self.layoutSizingHorizontal.oclIsUndefined() then
            if self.layoutSizingHorizontal.toString() = 'FILL' then 
                ', width: "100%"'
            else if self.layoutSizingHorizontal.toString() = 'HUG' then
                ', width: "fit-content"'
            else
                ''  -- Omit width for FIXED
            endif endif
        else
            ''  -- No explicit width if layoutSizingHorizontal is undefined
        endif) +
        (if not self.layoutSizingVertical.oclIsUndefined() then
            if self.layoutSizingVertical.toString() = 'FILL' then 
                ', height: "100%"'
            else if self.layoutSizingVertical.toString() = 'HUG' then
                ', height: "fit-content"'
            else
                ''  -- Omit height for FIXED
            endif endif
        else
            ''  -- No explicit height if layoutSizingVertical is undefined
        endif)
    in
    
    -- Margins based on constraints
    let marginStyles : String = 
        (if not self.constraints.oclIsUndefined() then
            (if not self.constraints.horizontal.oclIsUndefined() then
                (if self.constraints.horizontal.toString() = 'CENTER' then 
                    ', marginLeft: "auto", marginRight: "auto"'
                else if self.constraints.horizontal.toString() = 'RIGHT' then
                    ', marginLeft: "auto"'
                else if self.constraints.horizontal.toString() = 'LEFT' then
                    ', marginRight: "auto"'
                else
                    ''
                endif endif endif)
            else
                ''
            endif) +
            (if not self.constraints.vertical.oclIsUndefined() then
                (if self.constraints.vertical.toString() = 'CENTER' then 
                    ', marginTop: "auto", marginBottom: "auto"'
                else if self.constraints.vertical.toString() = 'BOTTOM' then
                    ', marginTop: "auto"'
                else if self.constraints.vertical.toString() = 'TOP' then
                    ', marginBottom: "auto"'
                else
                    ''
                endif endif endif)
            else
                ''
            endif)
        else
            ''
        endif)
    in
    
    -- Create the final style string - only including sections that aren't empty
    '{' + baseStyle + 
    (if fontStyles <> '' then fontStyles else '' endif) +
    (if textLayoutStyles <> '' then textLayoutStyles else '' endif) +
    (if textResizeStyles <> '' then textResizeStyles else '' endif) +
    (if colorStyles <> '' then colorStyles else '' endif) +
    (if layoutStyles <> '' then layoutStyles else '' endif) +
    (if marginStyles <> '' then marginStyles else '' endif) +
    '}';

-- Helper to check if a frame is a button container
helper context Figma!FRAME def : isButtonContainer() : Boolean =
    if self.isFrame() and 
       not self.name.oclIsUndefined() and 
       self.name.toString().toLowerCase().indexOf('button') <> -1 and
       not self.children.oclIsUndefined() and
       not self.children->isEmpty() and
       self.children->exists(c | c.isText())
    then
        true
    else
        false
    endif;

-- Helper to get the text child from a button container
helper context Figma!FRAME def : getButtonText() : Figma!TEXT =
    if not self.children.oclIsUndefined() and not self.children->isEmpty() then
        self.children->select(c | c.isText())->first()
    else
        OclUndefined
    endif;

-- Helper to generate comprehensive button styles from a frame
helper context Figma!FRAME def : generateButtonFrameStyles() : String =
    let baseStyles : String = 'display: flex' in
    
    -- Layout and alignment
    let layoutStyles : String = 
        (if not self.layoutMode.oclIsUndefined() then
            ', flexDirection: "' + 
            (if self.layoutMode.toString() = 'HORIZONTAL' then 'row' else 'column' endif) + '"'
        else 
            ', flexDirection: "row"'  -- Default to row
        endif) +
        (if not self.primaryAxisAlignItems.oclIsUndefined() then
            ', justifyContent: "' + 
            (if self.primaryAxisAlignItems.toString() = 'CENTER' then 'center'
             else if self.primaryAxisAlignItems.toString() = 'MIN' then 'flex-start'
             else if self.primaryAxisAlignItems.toString() = 'MAX' then 'flex-end'
             else if self.primaryAxisAlignItems.toString() = 'SPACE_BETWEEN' then 'space-between'
             else 'center'  -- Default to center
             endif endif endif endif) + '"'
        else
            ', justifyContent: "center"'  -- Default to center
        endif) +
        (if not self.counterAxisAlignItems.oclIsUndefined() then
            ', alignItems: "' + 
            (if self.counterAxisAlignItems.toString() = 'CENTER' then 'center'
             else if self.counterAxisAlignItems.toString() = 'MIN' then 'flex-start'
             else if self.counterAxisAlignItems.toString() = 'MAX' then 'flex-end'
             else 'center'  -- Default to center
             endif endif endif) + '"'
        else
            ', alignItems: "center"'  -- Default to center
        endif) +
        (if not self.itemSpacing.oclIsUndefined() then
            ', gap: "' + self.itemSpacing.toString() + 'px"'
        else
            ''
        endif) +
        (if not self.layoutWrap.oclIsUndefined() then
            ', flexWrap: "' + 
            (if self.layoutWrap.toString() = 'NO_WRAP' then 'nowrap' else 'wrap' endif) + '"'
        else
            ''
        endif)
    in
    
    -- Dimensions
    let dimensionStyles : String =
        (if not self.absoluteBoundingBox.oclIsUndefined() then
            ', width: "' + self.absoluteBoundingBox.width.toString() + 'px", ' +
            'height: "' + self.absoluteBoundingBox.height.toString() + 'px"'
        else
            ''
        endif)
    in
    
    -- Background and border
    let appearanceStyles : String =
        (if not self.backgroundColor.oclIsUndefined() then
            ', backgroundColor: "' + self.backgroundColor.toRGBA() + '"'
        else if not self.fills.oclIsUndefined() and not self.fills->isEmpty() and not self.fills->first().color.oclIsUndefined() then
            ', backgroundColor: "' + self.fills->first().color.toRGBA() + '"'
        else
            ''
        endif endif) +
        (if not self.cornerRadius.oclIsUndefined() then
            ', borderRadius: "' + self.cornerRadius.toString() + 'px"'
        else
            ''
        endif) +
        (if not self.strokeWeight.oclIsUndefined() and self.strokeWeight > 0 then
            ', borderWidth: "' + self.strokeWeight.toString() + 'px"'
        else
            ''
        endif) +
        (if not self.strokes.oclIsUndefined() and not self.strokes->isEmpty() and not self.strokes->first().color.oclIsUndefined() then
            ', borderColor: "' + self.strokes->first().color.toRGBA() + '"'
        else
            ''
        endif) +
        (if not self.strokeAlign.oclIsUndefined() then
            ', borderStyle: "solid"'
        else
            ''
        endif)
    in
    
    -- Other properties
    let otherStyles : String =
        ', cursor: "pointer", textDecoration: "none", userSelect: "none"'
    in
    
    -- Create the final style string
    '{' + baseStyles + layoutStyles + dimensionStyles + appearanceStyles + otherStyles + '}';


-- Rule to transform a frame with 'button' in the name and a text child to an HTML button
rule FigmaFrameButton2HtmlButton {
    from
        F : Figma!FRAME (
            F.isButtonContainer()
        )
    using {
        -- Get the text child to use as button content
        buttonText : Figma!TEXT = F.getButtonText();
    }
    to 
        R : React!HTMLElement (
            name <- if F.hasClickNavigation() then 'a' else 'button' endif,
            isSelfClosing <- false,
            key <- F.id,
            -- Use text character content if available
            content <- if F.hasClickNavigation() or buttonText.oclIsUndefined() then 
                        OclUndefined 
                       else 
                        buttonText.characters 
                       endif,
            -- Include navigation attributes if needed
            attributes <- if F.hasClickNavigation() then
                let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
                if not targetCanvas.oclIsUndefined() then
                    Sequence {
                        thisModule.CreateAttribute('href', '/' + thisModule.sanitizeName(targetCanvas.name)),
                        thisModule.CreateAttribute('style', F.generateButtonFrameStyles())
                    }
                else
                    Sequence {
                        thisModule.CreateAttribute('style', F.generateButtonFrameStyles()),
                        thisModule.CreateAttribute('id', F.id)
                    }
                endif
            else
                Sequence {
                    thisModule.CreateAttribute('style', F.generateButtonFrameStyles()),
                    thisModule.CreateAttribute('id', F.id),
                    thisModule.CreateAttribute('type', 'button')
                }
            endif,
            -- For navigation links, include wrapper with original text content
            children <- if F.hasClickNavigation() then
                let targetCanvas : Figma!Children = thisModule.findCanvasById(F.getNavigationDestination()) in
                if not targetCanvas.oclIsUndefined() and not buttonText.oclIsUndefined() then
                    Sequence {
                        thisModule.CreateButtonTextContentElement(buttonText)
                    }
                else
                    -- Otherwise, remove text child since we're using it as content
                    F.children->reject(c | c = buttonText)->collect(e | thisModule.resolveTemp(e, 'R'))
                endif
            else
                -- For regular buttons, remove text child since we're using it as content
                F.children->reject(c | c = buttonText)->collect(e | thisModule.resolveTemp(e, 'R'))
            endif
        )
}

-- Helper lazy rule to create content for button text with proper styling
lazy rule CreateButtonTextContentElement {
    from
        T : Figma!TEXT
    to
        R : React!HTMLElement (
            name <- 'span',
            isSelfClosing <- false,
            key <- T.id + '_button_content',
            content <- T.characters,
            attributes <- Sequence {
                thisModule.CreateAttribute('style', 
                    -- Generate comprehensive text styles
                    '{' +
                    -- Font properties
                    (if not T.style.oclIsUndefined() and not T.style.fontFamily.oclIsUndefined() then 
                        'fontFamily: "' + T.style.fontFamily + '"' 
                    else 
                        'fontFamily: "inherit"' 
                    endif) +
                    (if not T.style.oclIsUndefined() and not T.style.fontSize.oclIsUndefined() then 
                        ', fontSize: "' + T.style.fontSize + 'px"' 
                    else 
                        '' 
                    endif) +
                    (if not T.style.oclIsUndefined() and not T.style.fontWeight.oclIsUndefined() then 
                        ', fontWeight: ' + T.style.fontWeight 
                    else 
                        '' 
                    endif) +
                    -- Text layout
                    (if not T.style.oclIsUndefined() and not T.style.letterSpacing.oclIsUndefined() then 
                        ', letterSpacing: "' + T.style.letterSpacing + 'px"'
                    else 
                        '' 
                    endif) +
                    (if not T.style.oclIsUndefined() and not T.style.lineHeightPx.oclIsUndefined() then 
                        ', lineHeight: "' + T.style.lineHeightPx + 'px"'
                    else if not T.style.oclIsUndefined() and not T.style.lineHeightPercent.oclIsUndefined() then
                        ', lineHeight: "' + T.style.lineHeightPercent + '%"'
                    else 
                        '' 
                    endif endif) +
                    -- Text alignment
                    (if not T.style.oclIsUndefined() and not T.style.textAlignHorizontal.oclIsUndefined() then 
                        ', textAlign: "' + 
                        (if T.style.textAlignHorizontal.toString() = 'CENTER' then 
                            'center'
                        else if T.style.textAlignHorizontal.toString() = 'LEFT' then
                            'left'
                        else if T.style.textAlignHorizontal.toString() = 'RIGHT' then
                            'right'
                        else if T.style.textAlignHorizontal.toString() = 'JUSTIFIED' then
                            'justify'
                        else
                            'inherit'
                        endif endif endif endif) + '"'
                    else 
                        '' 
                    endif) +
                    -- Text color (using fills)
                    (if not T.fills.oclIsUndefined() and not T.fills->isEmpty() and not T.fills->first().color.oclIsUndefined() then 
                        ', color: "' + T.fills->first().color.toRGBA() + '"'
                    else 
                        ', color: "inherit"' 
                    endif) +
                    -- Dimensions (if available)
                    (if not T.absoluteBoundingBox.oclIsUndefined() then 
                        ', width: "' + T.absoluteBoundingBox.width + 'px", ' +
                        'height: "' + T.absoluteBoundingBox.height + 'px"'
                    else 
                        '' 
                    endif) +
                    -- Override these properties to ensure button text looks right
                    ', textDecoration: "inherit", margin: "0", padding: "0", pointerEvents: "none"' +
                    '}'
                )
            }
        )
}